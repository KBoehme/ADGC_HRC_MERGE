""" ADGC 2.0 - Relatedness analysis

 General overview of process
    1. Given raw genotyped snps for each study, create a list of common snps.
    2. LD-prune list of common snps.
    3. Extract these subset of snps from plink files.
    4. Run King-Robust on this LD-pruned, common dataset to generate list of related (within 3rd degree) individuals.
    6. Remove related individuals leaving one
    7. Run Eigenstrat on this LD-pruned, common, unrelated dataset to generate PC's
    8. Merge PC's with sample covariate files.


    snakemake -np --verbose -j 999 --cluster-config ../scripts/relatedness/cluster.json -s ../scripts/relatedness/Snakefile --cluster \
    "sbatch \
    --ntasks {cluster.ntasks} \
    --time {cluster.time} \
    --mem {cluster.mem} \
    --job-name {cluster.name} \
    --mail-type {cluster.mail-type} \
    --mail-user {cluster.mail-user} \
    --parsable" \
    --cluster-status ../scripts/slurm_status.py
"""

from pathlib import Path
from python_scripts import utils

# This is the shared folder location, however due to lack of space cant be used.
# ROOT = "/fslhome/fslcollab192/fsl_groups/fslg_KauweLab/compute/ADGC_2018_combined/alois.med.upenn.edu/"
ROOT = "/fslhome/fslcollab192/compute"
WORKING_DIR = "ADGC_HRC_COMBINE_bkup"
WORKFLOW_NAME = "relatedness_workflow"
# RESOURCES_DATA_FOLDER = "resources"
# SCRIPTS_DATA_FOLDER = "scripts/python_scripts"
BIM_DATA_SOURCE = os.path.join(ROOT, "ADGC_Data", "ADGC_Raw", "bims")
PROCESS_DATA_SOURCE = os.path.join(ROOT, WORKING_DIR, "process", WORKFLOW_NAME)

FINAL_DATA_SOURCE = os.path.join(ROOT, WORKING_DIR, "final")
EXTRA_FOLDER = os.path.join(FINAL_DATA_SOURCE, "auxiliary")

# RESOURCES = os.path.join(ROOT, RESOURCES_DATA_FOLDER)
# SCRIPTS = os.path.join(ROOT, SCRIPTS_DATA_FOLDER)
LOGS = os.path.join(PROCESS_DATA_SOURCE, "logs")
PLINK_EXT = ["bed", "bim", "fam"]
KING1_EXT = ["TMP.ped", "TMP.dat", "unrelated.txt", "updateids.txt"]
KING2_EXT = ["allsegs.txt", "unrelated_toberemoved.txt", "unrelated.txt"]

localrules: bim_to_snp_ids_only, get_common_snps, remap_fids_for_king, copy_qc_common_snps_to_extra

BIM_NAMES = [Path(name).stem for name in os.listdir(BIM_DATA_SOURCE)]

rule all:
    """ This is an artificial snakemake rule that basically specifies as input
    the final files im attempting to get out of the workflow."""
    input:
        # os.path.join(EXTRA_FOLDER,  "adgc_hrc_merged_common_qc_snps.bim"),
        os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.pca.par"),
        expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning","plink", "adgc_hrc_rel_cutoff.{ext}"), ext=PLINK_EXT),
        os.path.join(EXTRA_FOLDER, "adgc_hrc_unrelated_ids.txt")

rule eigenstrat:
    """Must convert long ID's to temporary shortened ID's to make eigenstrat happy.. Eww
    04:30:00 runtime. Comment out plink or king, depending on what we end up
    using.
    """
    input:
        bed=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","king1", "adgc_hrc_unrelated.bed"),
        fam=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","king1", "adgc_hrc_unrelated.fam"),
        bim=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","king1", "adgc_hrc_unrelated.bim")
        # bed=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","plink", "adgc_hrc_rel_cutoff.bed"),
        # fam=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","plink", "adgc_hrc_rel_cutoff.fam"),
        # bim=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","plink", "adgc_hrc_rel_cutoff.bim")
    output:
        pca=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.pca.par"),
        eval=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.pca.evec")
    params:
        pca=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.pca"),
        eval=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.eval"),
        plot=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.plot"),
        number_pca=10
    log:
        os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "eigen", "adgc_pruned_3unrelated.log")
    shell:
        "module load eigensoft/4.2; \
        /fslhome/fslcollab192/fsl_groups/fslg_KauweLab/compute/ADGC_2018_combined/alois.med.upenn.edu/programs/EIG-7.2.1/bin/smartpca.perl \
        -i {input.bed} -a {input.bim} \
        -b {input.fam} -o {params.pca} \
        -p {params.plot} -e {params.eval} \
        -l {log} -m 0 -k {params.number_pca}"

############################ Pruned unrelated set complete ####################

rule convert_king_unrelated_set_ids_back:
    """ the king unrelated file is in shortened ids. We must now look up these
    id's and get them back to the long ones.
    ADC1_NACC548317_08AD7682___NACC548317_08AD7682 NACC548317_08AD7682 FID_1 IID_1
    """
    input:
        king_unrelated=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king1", "adgc_hrc_kingunrelated.txt"),
        id_map=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "short_name_update.txt")
    output:
        adgc_unrelated_ids=os.path.join(EXTRA_FOLDER, "adgc_hrc_unrelated_ids.txt")
    shell:
        utils.create_remap_file(input.king_unrelated, input.id_map, adgc_unrelated_ids)

# Use rule if using King Robust to filter
rule prune_unrelated_short_ids:
    """ Use list of king unrelated samples as input to a --keep plink command.
    NOTICE: Make sure King removes all the samples!
    """
    input:
        king_unrelated=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king1", "adgc_hrc_kingunrelated.txt"),
        final_pruned_bfiles=expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames.{ext}"), ext=PLINK_EXT)
    output:
        expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king1", "adgc_hrc_unrelated.{ext}"), ext=PLINK_EXT)
    params:
        input_plink_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames"),
        output_plink_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king1", "adgc_hrc_unrelated")
    shell:
        "plink --bfile {params.input_plink_base} --keep {input.king_unrelated} --make-bed --out {params.output_plink_base}"

rule plink_rel_cutoff:
    """ Just trying to do the rel cutoff using plink 1.9. Seems to get similiar
    (few less) samples at the end. Save a step of using plink to extract a list
    of unrelated samples.
    """
    input:
        final_pruned_bfiles=expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames.{ext}"), ext=PLINK_EXT)
    output:
        output=expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning","plink", "adgc_hrc_rel_cutoff.{ext}"), ext=PLINK_EXT)
    params:
        input_plink_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames"),
        output_plink_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "plink", "adgc_hrc_rel_cutoff"),
        related_cutoff=0.125
    shell:
        "plink --bfile {params.input_plink_base} \
        --rel-cutoff {params.related_cutoff} \
        --make-bed --out {params.output_plink_base}"

rule king_robust2:
    """ Run KingRobust 2.1.5 with 3rd degree relative cutoff, but it only
    ever does 2nd degree ;/
    """
    input:
        final_pruned_bfiles=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames.bed")
    output:
        king_output=expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king2", "adgc_hrc_king{ext}"), ext=KING2_EXT)
    params:
        king_output_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "king2", "adgc_hrc_king"),
        related_cutoff=3
    shell:
        "/fslhome/fslcollab192/fsl_groups/fslg_KauweLab/compute/ADGC_2018_combined/alois.med.upenn.edu/programs/king2.1.5 \
        -b {input.final_pruned_bfiles} --unrelated \
        --degree {params.related_cutoff} \
        --prefix {params.king_output_base}"

rule king_robust1:
    """ Run KingRobust 1.4 with 3rd degree relative cutoff
    /fslhome/fslcollab192/fsl_groups/fslg_KauweLab/compute/ADGC_2018_combined/alois.med.upenn.edu/programs/king2.1.5
    """
    input:
        final_pruned_bfiles=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames.bed")
    output:
        king_output=expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning","king1", "adgc_hrc_king{ext}"), ext=KING1_EXT)
    params:
        king_output_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning","king1", "adgc_hrc_king"),
        related_cutoff=3
    shell:
        "/fslhome/fslcollab192/fsl_groups/fslg_KauweLab/compute/ADGC_2018_combined/alois.med.upenn.edu/programs/king1.4 \
        -b {input.final_pruned_bfiles} --unrelated \
        --degree {params.related_cutoff} \
        --prefix {params.king_output_base}"

rule shorten_ids:
    """ Take list of unrelated samples from previous steps and keep them, and
    renames samples for eigenstrat.
    1. Run plink to keep unrelated.
    2. Rename to shorter ID's
    """
    input:
        final_pruned_bfiles=expand(os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps.{ext}"), ext=PLINK_EXT)
    output:
        expand(os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames.{ext}"), ext=PLINK_EXT)
    params:
        input_fam=os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps.fam"),
        input_plink_base=os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps"),
        output_plink_base=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "adgc_hrc_shortnames"),
        update_id_file=os.path.join(PROCESS_DATA_SOURCE, "related_pruning", "short_name_update.txt")
    shell:
        "awk '{{print($1, $2, \"F\"NR, \"I\"NR)}}' {params.input_fam} > {params.update_id_file} && \
        plink --bfile {params.input_plink_base} \
        --update-ids {params.update_id_file} \
        --make-bed --out {params.output_plink_base}"

# Tested this out to see if making all the same FID or all different FID's
# changed anything. Decided to keep FID's the same.
# rule remap_fids_for_king:
#     """ Update sample information
#         --update-ids [filename]
#         These update sample IDs, parental codes, and sexes, respectively. --update-parents now also updates founder/nonfounder status in the current run when appropriate.
#         --update-ids expects input with the following four fields:
#             Old family ID
#             Old within-family ID
#             New family ID
#             New within-family ID
#
#     "awk '{{print($1, $2, \"IID_\"NR, \"FID_\"NR)}}' {params.fam} > {params.update_id_file} && \
#     """
#     input:
#         expand(os.path.join(PROCESS_DATA_SOURCE, "qced", "adgc_hrc_merged_common_qc_snps.{ext}"), ext=PLINK_EXT)
#     output:
#         expand(os.path.join(PROCESS_DATA_SOURCE, "short_names", "adgc_short_names.{ext}"), ext=PLINK_EXT)
#     params:
#         fam=os.path.join(PROCESS_DATA_SOURCE, "qced", "adgc_hrc_merged_common_qc_snps.fam"),
#         input_plink_base=os.path.join(PROCESS_DATA_SOURCE, "qced", "adgc_hrc_merged_common_qc_snps"),
#         output_plink_base=os.path.join(PROCESS_DATA_SOURCE, "short_names", "adgc_short_names"),
#         update_id_file=os.path.join(PROCESS_DATA_SOURCE, "short_names", "short_name_update.txt")
#     shell:
#         "awk '{{print($1, $2, \"IID_\"NR, \"FID_\"NR)}}' {params.fam} > {params.update_id_file} && \
#         plink --bfile {params.input_plink_base} \
#         --update-ids {params.update_id_file} \
#         --make-bed --out {params.output_plink_base}"

rule copy_qc_common_snps_to_extra:
    """ Simply copies the bim from previous step to final folder."""
    input:
        os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps.bim")
    output:
        os.path.join(EXTRA_FOLDER,  "adgc_hrc_merged_common_qc_snps.bim")
    shell:
        "cp {input} {output}"

# rule plink_final_prune:
#     """ Takes the prune.in file (maf, geno, indep filters) and creates the final plink set.
#     Upon reading the King documentation is suggests not LD-pruning.
#     Uses plink 1.9
#     Previously used following params
#     Options in effect:
#             --noweb
#             --bfile adgc_combined_common_snps
#             --maf 0.01
#             --geno 0.02
#             --indep-pairwise 1500 150 0.2
#             --out adgc.combined.commonsnps.thinned
#     """
#     input:
#         common_snps_bfile=expand(os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_snps.{ext}"), ext=PLINK_EXT)
#     output:
#         final_pruned_bfiles=expand(os.path.join(PROCESS_DATA_SOURCE, "qced", "adgc_hrc_merged_common_qc_snps.{ext}"), ext=PLINK_EXT)
#     params:
#         input_plink_base=os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_snps"),
#         output_plink_base=os.path.join(PROCESS_DATA_SOURCE, "qced", "adgc_hrc_merged_common_qc_snps")
#     shell:
#         "plink --bfile {params.input_plink_base} \
#         --extract {params.input_plink_base}.prune.in \
#         --make-bed --out {params.output_plink_base}"

rule plink_extract_common_snps_and_filter:
    """ Extracts subset of common SNP's from plink files and then immediately filters and prunes them.
    Plink outputs a file called prune.in/prune.out as a result of the maf, geno, indep filters. Must do
    another plink call to extract the prune.in variants.

    Uses plink 1.9
    """
    input:
        bed=os.path.join(FINAL_DATA_SOURCE, "plink", "adgc_hrc_merged_qced.bed"),
        fam=os.path.join(FINAL_DATA_SOURCE, "plink", "adgc_hrc_merged_qced.fam"),
        bim=os.path.join(FINAL_DATA_SOURCE, "plink", "adgc_hrc_merged_qced.bim"),
        common_snps=os.path.join(EXTRA_FOLDER, "adgc_hrc_common_snps.txt")
    output:
        common_extracted=expand(os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps.{ext}"), ext=PLINK_EXT)
    params:
        plink_base=os.path.join(PROCESS_DATA_SOURCE, "adgc_hrc_merged_common_qc_snps"),
        maf=0.01,
        geno=0.02,
    shell:
        "plink --bed  {input.bed} \
        --fam {input.fam} \
        --bim {input.bim} \
        --extract {input.common_snps} \
        --maf {params.maf} \
        --geno {params.geno} \
        --make-bed --out {params.plink_base}"

rule get_common_snps:
    """ Using a simple python script intersect all input files. Input files
    are expected to be a snp id per line."""
    input:
        # snps=expand(os.path.join(PROCESS_DATA_SOURCE, "bim_snps", "{study}.bim"), study=wildcards.study) # Would love to be able to do this..
        snps=lambda wildcards: [os.path.join(PROCESS_DATA_SOURCE, "bim_snps", "{}.bim".format(bim)) for bim in BIM_NAMES]
    output:
        common_snps=os.path.join(EXTRA_FOLDER, "adgc_hrc_common_snps.txt")
    run:
        setlist = []
        for file in input:
            print("Working on file: {}".format(file))
            setlist.append(set(line.strip() for line in open(file, 'r')))
        common_snps = set.intersection(*setlist)
        print(output.common_snps)
        with open(output.common_snps, "w") as f:
            for snp in common_snps:
                f.write(snp + "\n")

rule bim_to_snp_ids_only:
    """ awks out snp ids from bim files and write to new file.
    """
    input:
        bim=os.path.join(BIM_DATA_SOURCE, "{study}.bim")
    output:
        snp=os.path.join(PROCESS_DATA_SOURCE, "bim_snps", "{study}.bim")
    shell:
        "awk '{{print $2}}' {input.bim} > {output.snp}"
